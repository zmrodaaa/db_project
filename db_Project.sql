---(9)
alter session set "_oracle_script"=true;
create user User1 identified by 123;
GRANT CREATE SESSION , CREATE TABLE TO  User1;
create user User2 identified by 123;
GRANT CREATE SESSION TO  User2;
--------------------
--create tables
------------------------------
CREATE TABLE Students (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
    name VARCHAR2(255) NOT NULL,              
    membership_status VARCHAR2(10) NOT NULL,        
    CONSTRAINT membership_status_check CHECK (membership_status IN ('active', 'suspended'))
);

CREATE TABLE BorrowingRecords (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
    book_id NUMBER,  
    student_id NUMBER,  
    borrow_date DATE NOT NULL, 
    return_date DATE, 
    status VARCHAR2(10) CHECK (status IN ('borrowed', 'returned')) NOT NULL, 
    FOREIGN KEY (book_id) REFERENCES user1.Books(id),
    FOREIGN KEY (student_id) REFERENCES Students(id)  
);

CREATE TABLE Penalties (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
    student_id NUMBER, 
    amount DECIMAL(10, 2) NOT NULL, 
    reason VARCHAR2(255) NOT NULL, 
    FOREIGN KEY (student_id) REFERENCES Students(id) 
);
CREATE TABLE NotificationLogs (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
    student_id NUMBER, 
    book_id NUMBER,  
    overdue_days NUMBER NOT NULL, 
    notification_date DATE NOT NULL,
    FOREIGN KEY (student_id) REFERENCES Students(id), 
    FOREIGN KEY (book_id) REFERENCES user1.Books(id) 
);


CREATE TABLE AuditTrail (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
    table_name VARCHAR2(255) NOT NULL, 
    operation VARCHAR2(10) CHECK (operation IN ('insert', 'update', 'delete')) NOT NULL, 
    old_data CLOB,  
    new_data CLOB,  
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP 
);
--insert tables
----------------------------
INSERT INTO user1.BookTypes (type_name, fee_rate) VALUES ('Regular Book', 1.00);
INSERT INTO user1.BookTypes (type_name, fee_rate) VALUES ('Reference Book', 2.50);


INSERT INTO user1.Books (title, author, availability, type_id) VALUES ('The Quran', 'allah', 'borrowed', 2);
INSERT INTO user1.Books (title, author, availability, type_id) VALUES ('Sapiens: A Brief History of Humankind', 'Yuval Noah Harari', 'available', 1);

INSERT INTO Students (name, membership_status) VALUES ('Ahmed Ali', 'active');
INSERT INTO Students (name, membership_status) VALUES ('Mona Mohamed', 'active');
INSERT INTO Students (name, membership_status) VALUES ('Omar Hassan', 'active');


INSERT INTO BorrowingRecords (book_id, student_id, borrow_date, return_date, status) VALUES (1, 1, TO_DATE('2024-12-01', 'YYYY-MM-DD'), TO_DATE('2024-12-10', 'YYYY-MM-DD'), 'returned');
INSERT INTO BorrowingRecords (book_id, student_id, borrow_date, return_date, status) VALUES (2, 2, TO_DATE('2024-11-15', 'YYYY-MM-DD'), TO_DATE('2024-11-25', 'YYYY-MM-DD'), 'borrowed');
INSERT INTO BorrowingRecords (book_id, student_id, borrow_date, return_date, status) VALUES (2, 3, TO_DATE('2024-12-01', 'YYYY-MM-DD'), TO_DATE('2024-12-2', 'YYYY-MM-DD'), 'borrowed');

INSERT INTO Penalties (student_id, amount, reason) VALUES (3, 5.00, 'Late return ');
INSERT INTO Penalties (student_id, amount, reason) VALUES (2, 10.00, 'Damaged book');

INSERT INTO AuditTrail (table_name, operation, old_data, new_data, timestamp) VALUES ('Books', 'update', '{"id": 1, "title": "The Alchemist"}', '{"id": 1, "title": "The Alchemist - Updated"}', TO_TIMESTAMP('2024-12-06 10:00:00', 'YYYY-MM-DD HH24:MI:SS'));
INSERT INTO AuditTrail (table_name, operation, old_data, new_data, timestamp) VALUES ('Students', 'insert', 'NULL', '{"id": 1, "name": "Ahmed Ali", "membership_status": "active"}', TO_TIMESTAMP('2024-12-06 10:10:00', 'YYYY-MM-DD HH24:MI:SS'));


INSERT INTO NotificationLogs (student_id, book_id, overdue_days, notification_date) VALUES (1, 1, 5, TO_DATE('2024-12-06', 'YYYY-MM-DD'));
INSERT INTO NotificationLogs (student_id, book_id, overdue_days, notification_date) VALUES (2, 2, 10, TO_DATE('2024-11-25', 'YYYY-MM-DD'));


------------------------------------------
-- (1)create PROCEDURE send_overdue_notifications
CREATE OR REPLACE PROCEDURE send_overdue_notifications AS
BEGIN
    -- Loop through borrowing records where the book is still borrowed and is overdue by more than 7 days
    FOR notifications IN 
        (SELECT br.student_id, br.book_id, 
                TRUNC(SYSDATE) - br.return_date AS overdue_days 
         FROM BorrowingRecords br
         WHERE br.status = 'borrowed' 
         AND br.return_date < SYSDATE - 7) 
    LOOP
        BEGIN
            INSERT INTO NotificationLogs(student_id, book_id, overdue_days, notification_date)
            VALUES (notifications.student_id, notifications.book_id, notifications.overdue_days, SYSDATE);  
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Error for book ID: ' || notifications.book_id || ' - ' || SQLERRM);
        END;
    END LOOP;

    COMMIT;
END send_overdue_notifications;
--------------------------------------
--CALL send_overdue_notifications();
---------------------------------------
--(2)create calculate_dynamic_late_fee
CREATE OR REPLACE FUNCTION calculate_dynamic_late_fee(borrow_record_id IN NUMBER) 
RETURN NUMBER IS
    overdue_days NUMBER;
    book_type NUMBER;
    fee_per_day NUMBER;
    total_fee NUMBER;
BEGIN
    -- Get the number of overdue days by calculating the difference between today's date and the return date
    SELECT TRUNC(SYSDATE) - br.return_date INTO overdue_days
    FROM BorrowingRecords br
    WHERE br.id = borrow_record_id
    AND br.return_date IS NOT NULL;

    -- Get the type of book (e.g., regular, reference) 
    SELECT b.type_id INTO book_type
    FROM BorrowingRecords br
    JOIN user1.Books b ON br.book_id = b.id
    WHERE br.id = borrow_record_id;

    -- Determine the fee per day based on the book type
    IF book_type = 1 THEN 
        fee_per_day := 1; --regular
    ELSIF book_type = 2 THEN 
        fee_per_day := 2; --reference
    ELSE
        fee_per_day := 1.5;  -- Default to no fee if the type is unknown
    END IF;

    total_fee := overdue_days * fee_per_day;

    -- Insert the penalty record into the Penalties table
    INSERT INTO Penalties(student_id, amount, reason)
    SELECT br.student_id, total_fee, 'Late Fee'
    FROM BorrowingRecords br
    WHERE br.id = borrow_record_id;

    COMMIT;

    -- Return the calculated late fee
    RETURN total_fee;
END calculate_dynamic_late_fee;
----------------------------------------
--SET SERVEROUTPUT ON;
--DECLARE
--    late_fee NUMBER;
--BEGIN
--    -- Call the function and store the result in a variable
--    late_fee := calculate_dynamic_late_fee(3);
--
--    -- Output the late fee (optional)
--    DBMS_OUTPUT.PUT_LINE('The calculated late fee is: ' || late_fee);
--END;
------------------------------------------
-- (3) Trigger to validate borrowing conditions 
CREATE OR REPLACE TRIGGER check_borrowing_validation
BEFORE INSERT ON BorrowingRecords
FOR EACH ROW
DECLARE
    overdue_count NUMBER;
    borrow_limit_max NUMBER := 3;
    borrowed_count NUMBER;
BEGIN
    -- Check if the student has any overdue books
    SELECT COUNT(*) INTO overdue_count
    FROM BorrowingRecords br
    WHERE br.student_id = :NEW.student_id
    AND br.status = 'borrowed' 
    AND br.return_date < SYSDATE;

    -- If the student has overdue books, raise an exception
    IF overdue_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Student has overdue books and cannot borrow more.');
    END IF;

    -- Check if the student has already borrowed the maximum allowed number of books
    SELECT COUNT(*) INTO borrowed_count
    FROM BorrowingRecords br
    WHERE br.student_id = :NEW.student_id
    AND br.status = 'borrowed';  

    -- If the student has reached the borrowing limit, raise an exception
    IF borrowed_count >= borrow_limit_max THEN
        RAISE_APPLICATION_ERROR(-20002, 'Student has reached the borrowing limit of ' || borrow_limit_max || ' books.');
    END IF;
END check_borrowing_validation;
---------------------------------
--INSERT INTO BorrowingRecords (student_id, book_id, status, return_date)
--VALUES (3, 1, 'borrowed', TO_DATE('2024-12-25', 'YYYY-MM-DD'));
---------------------------------
-----(4)create TRIGGER AuditTrail
CREATE OR REPLACE TRIGGER AuditTrail
BEFORE UPDATE OR DELETE
ON BorrowingRecords
FOR EACH ROW
BEGIN
    -- Insert record for UPDATE operation
    IF UPDATING THEN
        INSERT INTO AuditTrail (table_name, operation, old_data, new_data, timestamp)
        VALUES ('BorrowingRecords', 'update', 
                'Old data: ' || :OLD.return_date || ', ' || :OLD.student_id, 
                'New data: ' || :NEW.return_date || ', ' || :NEW.student_id, 
                SYSDATE);

    -- Insert record for DELETE operation
    ELSIF DELETING THEN
        INSERT INTO AuditTrail (table_name, operation, old_data, new_data, timestamp)
        VALUES ('BorrowingRecords', 'delete', 
                'Old data: ' || :OLD.book_id || ', ' || :OLD.student_id, 
                NULL, SYSDATE);
    END IF;
END;
-----------------------------------
--UPDATE BorrowingRecords
--SET status = 'borrowed', return_date = TO_DATE('2024-12-20', 'YYYY-MM-DD')
--WHERE student_id = 2
--AND book_id = 2;
---------------------------------
--(5)Borrowing History Report for student id
CREATE OR REPLACE PROCEDURE GetBorrowingHistory (studentId IN NUMBER) IS
    CURSOR history_cursor 
    IS
        -- Query to fetch borrowing history details for a specific student
        SELECT b.title, br.borrow_date, br.return_date, br.status,
               TRUNC(SYSDATE) - br.return_date AS overdue_days,
               p.amount
        FROM BorrowingRecords br
        JOIN user1.Books b ON br.book_id = b.id
        LEFT JOIN Penalties p ON br.student_id = p.student_id
        WHERE br.student_id = studentId;
BEGIN
    -- Loop through each borrowing record fetched by the cursor
    FOR history_record IN history_cursor LOOP
        DBMS_OUTPUT.PUT_LINE('Book Title: ' || history_record.title);
        DBMS_OUTPUT.PUT_LINE('Borrow Date: ' || TO_CHAR(history_record.borrow_date, 'YYYY-MM-DD'));
        DBMS_OUTPUT.PUT_LINE('Return Date: ' || TO_CHAR(history_record.return_date, 'YYYY-MM-DD'));
        DBMS_OUTPUT.PUT_LINE('Status: ' || history_record.status);
        
        IF history_record.overdue_days > 0 THEN
            DBMS_OUTPUT.PUT_LINE('Overdue Days: ' || history_record.overdue_days);
        END IF;
        
        IF history_record.amount IS NOT NULL THEN
            DBMS_OUTPUT.PUT_LINE('Penalty: ' || history_record.amount);
        END IF;
    END LOOP;
END;
----------------------------
--EXEC GetBorrowingHistory(2); 
-----------------------------
--(6)Safe Return Process with Transactions
DECLARE
    penalty_amount NUMBER; 
    studentId NUMBER := 1; 
    overdue_count NUMBER;   -- Number of overdue books

BEGIN
        -- Check if the student has any penalties
        SELECT SUM(amount) 
        INTO penalty_amount
        FROM Penalties
        WHERE student_id = studentId;

        -- If the student has penalties, prevent returning books
        IF penalty_amount > 0 THEN
            DBMS_OUTPUT.PUT_LINE('The student has overdue penalties, cannot return books.');
            ROLLBACK;  -- Rollback the transaction
            RETURN;    -- Exit the procedure
        END IF;

        -- Check if the student has any overdue books
        SELECT COUNT(*) 
        INTO overdue_count
        FROM BorrowingRecords
        WHERE student_id = studentId 
          AND status = 'borrowed'
          AND SYSDATE > return_date;  

        -- If there are overdue books, update the penalties
        IF overdue_count > 0 THEN
            UPDATE Penalties
            SET amount = amount + 5.00 
            WHERE student_id = studentId AND reason = 'Late return';
        END IF;

        -- Mark books as returned if no penalties are found
        UPDATE BorrowingRecords
        SET status = 'returned', return_date = SYSDATE
        WHERE student_id = studentId AND status = 'borrowed';

        COMMIT;  -- Commit the transaction if all updates are successful
        DBMS_OUTPUT.PUT_LINE('Books successfully returned and penalties updated.');

    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);  -- Output error message
            ROLLBACK;  -- Rollback the transaction in case of an error
END;
------------------------------
--(7)Books Report
DECLARE
BEGIN
    DBMS_OUTPUT.PUT_LINE('--- Books Availability Report ---');
    DBMS_OUTPUT.PUT_LINE('ID | Title | Author | Type | Availability | Borrowed By | Overdue Days');
    DBMS_OUTPUT.PUT_LINE('-------------------------------------------------------------------------');
    
    -- Loop through the result set containing the books and their availability details
    FOR book_record IN (
        SELECT b.id AS book_id, 
               b.title, 
               b.author, 
               bt.type_name AS book_type, 
               b.availability, 
               NVL(s.name, 'N/A') AS borrowed_by,
               -- Calculate overdue days for borrowed books 
               CASE 
                   WHEN br.return_date < SYSDATE AND br.status = 'borrowed' THEN TRUNC(SYSDATE - br.return_date)
                   ELSE 0
               END AS overdue_days
        FROM user1.Books b
        LEFT JOIN user1.BookTypes bt ON b.type_id = bt.id
        LEFT JOIN BorrowingRecords br ON b.id = br.book_id 
        LEFT JOIN Students s ON br.student_id = s.id
    ) LOOP
        DBMS_OUTPUT.PUT_LINE(
            book_record.book_id || ' | ' || book_record.title || ' | ' || 
            book_record.author || ' | ' || book_record.book_type || ' | ' || 
            book_record.availability || ' | ' || book_record.borrowed_by || ' | ' || 
            book_record.overdue_days
        );
    END LOOP;
END;
-----------------------
--(8)
CREATE OR REPLACE PROCEDURE AutoSuspendStudents IS
    penalty_max NUMBER := 50; 
    -- store total penalties for a student
    total_penalties NUMBER;
BEGIN
    -- Loop through all students and check their total penalties
    FOR student_record IN (
        SELECT student_id 
        FROM Penalties 
        GROUP BY student_id
    ) LOOP
        -- Get the total unpaid penalties for the current student
        SELECT SUM(amount) 
        INTO total_penalties
        FROM Penalties
        WHERE student_id = student_record.student_id;

        -- If the total penalties exceed the threshold, suspend the student
        IF total_penalties > penalty_max THEN
            UPDATE Students
            SET membership_status = 'suspended'
            WHERE id = student_record.student_id;

            DBMS_OUTPUT.PUT_LINE('Student ' || student_record.student_id || ' has been suspended due to exceeding the penalty threshold.');
        END IF;
    END LOOP;

    COMMIT;  -- Commit the changes to the database
END AutoSuspendStudents;
--------------------------------
--BEGIN
--    AutoSuspendStudents;
--END;
-------------------------------
GRANT ALL ON BorrowingRecords TO user1;
GRANT ALL ON  Penalties TO user2;
-- INSERT INTO Students (name, membership_status) VALUES ('yousef Ali', 'active');

--------------------
-----(9)
-----user 1
CREATE TABLE BookTypes (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,   
    type_name VARCHAR2(50) NOT NULL,                   
    fee_rate NUMBER(10, 2) NOT NULL        
);
CREATE TABLE Books (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,   
    title VARCHAR2(255) NOT NULL,                     
    author VARCHAR2(255) NOT NULL,                
    availability VARCHAR2(10) CHECK (availability IN ('available', 'borrowed')) NOT NULL,  
    type_id NUMBER,                                            
    FOREIGN KEY (type_id) REFERENCES BookTypes(id)   
);

GRANT insert ON BookTypes TO user2;
GRANT insert ON Books TO user2;

--User 2 insert 5 rows of book details and their respective types into the tables.
INSERT INTO user1.BookTypes (type_name, fee_rate) VALUES ('Fiction', 1.50);
INSERT INTO user1.BookTypes (type_name, fee_rate) VALUES ('Science', 2.00);
INSERT INTO user1.BookTypes (type_name, fee_rate) VALUES ('History', 1.75);
INSERT INTO user1.BookTypes (type_name, fee_rate) VALUES ('Biography', 2.50);
INSERT INTO user1.BookTypes (type_name, fee_rate) VALUES ('Fantasy', 1.25);
INSERT INTO user1.BookTypes (type_name, fee_rate) VALUES ('Mystery', 2.20);

INSERT INTO user1.Books (title, author, availability, type_id) VALUES ('1984', 'George Orwell', 'available', 1);
INSERT INTO user1.Books (title, author, availability, type_id) VALUES ('A Brief History of Time', 'Stephen Hawking', 'borrowed', 2);
INSERT INTO user1.Books (title, author, availability, type_id) VALUES ('The Diary of a Young Girl', 'Anne Frank', 'available', 3);
INSERT INTO user1.Books (title, author, availability, type_id) VALUES ('Steve Jobs', 'Walter Isaacson', 'available', 4);
INSERT INTO user1.Books (title, author, availability, type_id) VALUES ('The Hobbit', 'J.R.R. Tolkien', 'borrowed', 5);
INSERT INTO user1.Books (title, author, availability, type_id) VALUES ('The Da Vinci Code', 'Dan Brown', 'available', 6);


--------------------------------
---(10)
--user 1
INSERT INTO systemManager.BorrowingRecords (book_id, student_id, borrow_date, return_date, status) VALUES (13, 6, TO_DATE('2024-12-01', 'YYYY-MM-DD'), TO_DATE('2024-12-10', 'YYYY-MM-DD'), 'returned');
--user 2
INSERT INTO systemManager.Penalties (student_id, amount, reason) VALUES (6, 5.00, 'Late return ');




------------------------------
-----(11) fetches information about sessions that are waiting for resources (blocked by another session).
SELECT 
    w.sid AS "Waiting Session",
    w.serial# AS "Waiting Serial Id",
    w.blocking_session AS "Blocker Session Id",
    w.seconds_in_wait AS "Waiting Session Period",
    v.sql_fulltext AS "Waiting Session SQL Statement"
FROM 
    v$session w 
JOIN 
    v$sql v ON w.sql_id = v.sql_id
WHERE 
    w.blocking_session IS NOT NULL;



-------------------------------
-------(12)
---user 1
-- Update the book information for a book with id 7.
 UPDATE Books
SET title = 'The Alchemist',
    author = 'Paulo Coelho',
    availability = 'available',
    type_id = 7
WHERE id=7 ;

-- Update the borrowing record for book 3 and student 4:
UPDATE systemManager.BorrowingRecords
SET borrow_date = TO_DATE('2024-12-01', 'YYYY-MM-DD'),
    return_date = TO_DATE('2024-12-10', 'YYYY-MM-DD'),
    status = 'returned'
WHERE book_id = 3 AND student_id = 4;

---user2
-- Update the book information for a book with id 7, in a different schema (user1.Books). Same changes as user 1.
 UPDATE user1.Books
SET title = 'The Alchemist',
    author = 'Paulo Coelho',
    availability = 'available',
    type_id = 7
WHERE id=7 ;

-- Update the borrowing record in systemManager.BorrowingRecords schema, same as user 1.
UPDATE systemManager.BorrowingRecords
SET borrow_date = TO_DATE('2024-12-01', 'YYYY-MM-DD'),
    return_date = TO_DATE('2024-12-10', 'YYYY-MM-DD'),
    status = 'returned'
WHERE book_id = 3 AND student_id = 4;

